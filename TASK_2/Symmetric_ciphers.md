Tables of contens
=================
* [I. T·ªïng quan](#i-t·ªïng-quan-v·ªÅ-m√£-kh√≥a-ƒë·ªëi-x·ª©ng)
  * [1. M·∫≠t m√£ ƒë·ªëi x·ª©ng l√† g√¨](#1-m·∫≠t-m√£-ƒë·ªëi-x·ª©ng-l√†-g√¨-)
  * [2. M·ªôt v√†i th√¥ng tin ph·ª•](#2-m·ªôt-v√†i-th√¥ng-tin-b·ªï-sung)
* [II. M√£ kh√≥a](#ii-c√°c-lo·∫°i-m√£-kh√≥a)

## I. T·ªïng quan v·ªÅ m√£ kh√≥a ƒë·ªëi x·ª©ng

### 1. M·∫≠t m√£ ƒë·ªëi x·ª©ng l√† g√¨ ?

M·∫≠t m√£ kh√≥a ƒë·ªëi x·ª©ng l√† m·ªôt lo·∫°i s∆° ƒë·ªì m√£ h√≥a trong ƒë√≥ m·ªôt kh√≥a gi·ªëng nhau s·∫Ω v·ª´a ƒë∆∞·ª£c d√πng ƒë·ªÉ m√£ h√≥a, v·ª´a ƒë∆∞·ª£c d√πng ƒë·ªÉ gi·∫£i m√£ c√°c t·ªáp tin. M·∫≠t m√£ kh√≥a ƒë·ªëi x·ª©ng ƒë∆∞·ª£c s·ª≠ d·ª•ng r·ªông r√£i tr√™n nhi·ªÅu h·ªá th·ªëng m√°y t√≠nh kh√°c nhau nh·∫±m tƒÉng c∆∞·ªùng b·∫£o m·∫≠t cho d·ªØ li·ªáu. M·ªôt s∆° ƒë·ªì m√£ h√≥a ƒë·ªëi x·ª©ng th∆∞·ªùng s·ª≠ d·ª•ng m·ªôt kh√≥a ƒë∆°n ƒë∆∞·ª£c chia s·∫ª gi·ªØa 2 ho·∫∑c nhi·ªÅu ng∆∞·ªùi d√πng v·ªõi nhau. Kh√≥a duy nh·∫•t n√†y s·∫Ω ƒë∆∞·ª£c d√πng cho c·∫£ 2 t√°c v·ª• m√£ h√≥a v√† gi·∫£i m√£ c√°c vƒÉn b·∫£n th√¥ (c√°c tin nh·∫Øn ho·∫∑c m·∫£nh d·ªØ li·ªáu c·∫ßn ƒë∆∞·ª£c m√£ h√≥a). C√°c thu·∫≠t to√°n kh√≥a ƒë·ªëi x·ª©ng ƒë∆∞·ª£c s·ª≠ d·ª•ng r·ªông r√£i tr√™n nhi·ªÅu h·ªá th·ªëng m√°y t√≠nh kh√°c nhau nh·∫±m tƒÉng c∆∞·ªùng b·∫£o m·∫≠t cho d·ªØ li·ªáu. M·ª©c ƒë·ªô b·∫£o m·∫≠t c·ªßa c√°c h·ªá th·ªëng m√£ h√≥a ƒë·ªëi x·ª©ng s·∫Ω ph·ª• thu·ªôc v√†o ƒë·ªô kh√≥ trong vi·ªác suy ƒëo√°n ng·∫´u nhi√™n ra kh√≥a ƒë·ªëi x·ª©ng theo h√¨nh th·ª©c t·∫•n c√¥ng brute force. Trong s·ªë c√°c s∆° ƒë·ªì m√£ h√≥a ƒë·ªëi x·ª©ng ƒë∆∞·ª£c s·ª≠ d·ª•ng ng√†y nay th√¨ c√≥ 2 lo·∫°i th√¥ng d·ª•ng nh·∫•t l√† n·ªÅn t·∫£ng m·∫≠t m√£ block v√† stream.

### 2. M·ªôt v√†i th√¥ng tin b·ªï sung

- M·ªôt trong nh·ªØng m√£ kh√≥a ƒë·ªëi x·ª©ng ph·ªï bi·∫øn nh·∫©t ƒë·∫øn hi·ªán t·∫°i l√† AES ƒë∆∞·ª£c c√¥ng b·ªë nƒÉm 2001. Hi√™n t·∫°i n√≥ ph·ªï bi·∫øn t·ªõi m∆∞c m·ªôt s·ªë ph·∫ßn m√™m m√°y t√≠nh c√≥ ph·∫ßn t·ªáp l·ªánh ri√™ng ƒë·ªÉ th·ª±c hi√™n AES. !) n√≥ l√† m·ªôt m√£ kh√≥a hay c√≥ trong CTF n√™n c·∫ßn t·∫≠p trung v√†o n√≥.
- V·ªÅ c∆° b·∫£n m√£ kh√≥a ƒë·ªëi x·ª©ng ƒë∆∞·ª£c chia l√†m hai lo·∫°i c∆° b·∫£n l√† M√£ kh√≥a kh·ªëi (block cipher) v√† M√£ kh√≥a d√≤ng (stream cipher)
  - M√£ kh√≥a kh·ªëi l√† m√£ kh√≥a m√£ kh√≥a chia c√°c ƒëo·∫°n b·∫£n r√µ th√†nh c√°c ph·∫ßn b·∫±ng nhau r·ªìi m√£ kh√≥a l·∫ßn l∆∞·ª£t t·ª´ng ph·∫ßn (AES, DES, ...) v·ªõi c√πng m·ªôt key.
  - M√£ kh√≥a d√≤ng l√† m√£ kh√≥a m√† khi m√£ kh√≥a n√≥ ch·ªâ m√£ kh√≥a t·ª´ng bytes ho·∫∑c nhi·ªÅu bytes b·∫±ng c√°ch xor n√≥ v·ªõi m·ªôt lo·∫°t c√°c kh√≥a gi·∫£ (c≈©ng l√† AES, DES, ...)
- M√£ kh√≥a ƒë·ªëi x·ª©ng ch·ªâ ƒë·∫∑c bi·ªát ·ªü c√°ch n√≥ m√£ kh√≥a t·ª´ng kh·ªëi v√† mode m√£ kh√≥a c·ªßa n√≥. ƒê√¢y l√† ƒëi·ªÉm khi·∫øn n√≥ tr·ªü n√™n kh√≥ ph√° v·ª° n·∫øu h√¥ng ƒë·ªß am hi·ªÉu v·ªÅ lo·∫°i m√£ v√† mode ƒë√≥ th√¨ vi·ªác ph√° n√≥ g·∫ßn nh∆∞ l√† kh√¥ng th·ªÉ.
- Kh√¥ng hi·ªÉu sao c√°c m√£ kh√≥a c∆° b·∫£n nh∆∞ ceasar, hill c√°c th·ª© c≈©ng c√πng l√† mx kh√≥a ƒë·ªëi x·ª©ng m√† kh√¥ng th·∫•y n√≥i ƒë·∫øn üôÉ

## II. C√°c lo·∫°i m√£ kh√≥a

### 1. DES (data encrpyted standard)

a. T·ªïng quan v·ªÅ DES

+ ƒê∆∞·ª£c ph√°t tri·ªÉn b·ªüi NIST nƒÉm 1977
+ ƒê·∫ßu v√†o c·ªßa DES l√† c√°c block 64 bit v√† c√°c ƒë·∫ßu ra c≈©ng c√≥ 64 bit.
+ V·ªõi kh√≥a k c√≥ ƒë·ªô d√†i 56 bit(th·ª±c ra ban ƒë·∫ßu l√† 64 bit nh∆∞ng trong qu√° tr√¨nh m√£ h√≥a c√°c bit chia h·∫øt cho 8 ƒë∆∞·ª£c l·∫•y ƒë·ªÉ ki·ªÉm tra t√≠nh ch·∫Øn l·∫ª n√™n c√≤n l·∫°i 56)
+ Thu·∫≠t to√°n : ƒê√¢u ti√™n tr∆∞·ªõc khi ƒëi v√†o m√£ h√≥a n√≥ s·∫Ω chia th√¥ng tin c·ªßa b·∫£n r√µ th√†nh c√°c kh·ªëi 64 bit, t·ª´ng kh·ªëi n√†y s·∫Ω l·∫ßn l∆∞·ª£t ƒë∆∞·ª£c ƒë∆∞a v√†o m√£ h√≥a. M·ªói l·∫ßn m√£ h√≥a s·∫Ω c√≥ 16 chu tr√¨nh ch√≠nh.

b. Chi ti·∫øt


Ph·∫ßn t·∫°o kh√≥a:
  
+ T·ª´ kh√≥a 64 bit ban ƒë·∫ßu qua ph·∫ßn (Ho√°n v·ªã PC-1) Permuted choice - 1 lo·∫°i b·ªè c√°c bit ·ªü v·ªã tr√≠ chia h·∫øt cho 8(t·ª´ ƒë√≥ kh√≥a c√≤n l·∫°i 56 bit). T√°ch c√°c bit c√≤n l·∫°i l√†m 2 ph·∫ßn m·ªói ph·∫ßn c√≥ 28 b·ªât l√† 28 bit ƒë·∫ßu v√† 28 bit cu·ªëi(k√Ω hi·ªáu: 28 bit ƒë·∫ßu $C_0$, 28 bit cu·ªëi $D_0$)

![image](https://github.com/MinhFanBoy/KCSC_tranning/assets/145200520/9c503081-35cf-4c3d-be0f-4706976b7ec4)

  
+ D·ªãch tr√°i: ·ªü c√°c v√≤ng(1, 2, 9, 16) th√¨ ta dich tr√°i 1 bit, c√°c v√≤ng c√≤n l·∫°i d·ªãch tr√°i 2 bit.

![image](https://github.com/MinhFanBoy/KCSC_tranning/assets/145200520/63cd27a9-8bad-4ac0-b9b2-aab70b453c7b)

+ Sau khi d·ªãch v√≤ng tr√°i cho $C_0$ v√† $D_0$ th√¨ ta s·∫Ω cho v√†o ho√°n v·ªã PC-2 . Ho√°n v·ªã PC-2 v·ªÅ c∆° b·∫£n l√† gi·ªëng ho√°n v·ªã PC-1 ch·ªâ kh√°c ·ªü s·ª± ho√°n v·ªã khi c√°c b√≠t 9, 18, 25, 35, 38, 43 b·ªã l∆∞·ª£c b·ªè. Khi n√†y ƒë·∫ßu ra c·ªßa n√≥ s·∫Ω l√† 18. L∆∞u l·∫°i k·∫øt qu·∫£ sau khi v√≤ng d·ªãch tr√°i r·ªìi g√°n n√≥ v√†o $C_1$, $D_1$\

![image](https://github.com/MinhFanBoy/KCSC_tranning/assets/145200520/803f165d-406e-4d1b-aec7-fa44a06b734e)


Ph·∫ßn input:
+ C√°ch nh√¨n tr·ª±c quan m√£ h√≥a DES:

![image](https://github.com/MinhFanBoy/KCSC_tranning/assets/145200520/35dc8acf-a6c4-4ebe-8e67-d883106ccfcb)

+ T·ª´ng v√≤ng c·ªßa DES:

![image](https://github.com/MinhFanBoy/KCSC_tranning/assets/145200520/fe33099f-e1ce-4c30-a461-78ede91a279e)


> B·∫Øt ƒë·∫ßu
- Cho 64 bit qua ho√°n v·ªã Sau ƒë√≥ l·∫•y 64 bit chia l√†m 2 ph·∫ßn $l_0$ v√† $R_0$.
  
![image](https://github.com/MinhFanBoy/KCSC_tranning/assets/145200520/e445d333-af9d-4100-b77b-aba8fb5376d6)

- $R_0$ ƒë∆∞·ª£c ƒë∆∞a v√†o h√†m F.
  
![image](https://github.com/MinhFanBoy/KCSC_tranning/assets/145200520/b313f020-d7c2-4957-b188-c12f8b82fff6)

> B√™n trong h√†m F()

- ƒê∆∞a $R_0$ qua ho√°n v·ªã m·ªü r·ªông E. Ho√°n v·ªã m·ªü r·ªông E l√† l·∫∑p l·∫°i hai bit cu·ªëi c·ªßa h√†ng tr∆∞·ªõc ho·∫∑c h√†ng sau. M·ª•c ƒë√≠ch c·ªßa n√≥ l√† ƒë·ªÉ tƒÉng s·ªë bit l√™n 48 ƒë·ªÉ $XOR$ v·ªõi c·∫£ $key$ c≈©ng c√≥ 48 bits.


![image](https://github.com/MinhFanBoy/KCSC_tranning/assets/145200520/78a27ded-a166-4310-b2e0-d2294ea221fb)

- Sau khi $R_0$ xor v·ªõi $K_0$ th√¨ ta cho n√≥ qua v√≤ng s-box ƒë·ªÉ chuy·ªÉn n√≥ v·ªÅ l·∫°i 32 bit. Trong S_box ta t√°ch m·ªói ph·∫ßn t·ª≠ c·ªßa tr·∫°ng th√°i th√†nh hai ph·∫ßn g·ªìm hai bit ·ªü ƒë·∫ßu v√† cu·ªëi [0][-1] v√† c√°c bit c√≤n l·∫°i [1:-2], ƒë·ªëi chi·∫øu n√≥ theo b·∫£ng sau ƒë√¢y:

![image](https://github.com/MinhFanBoy/KCSC_tranning/assets/145200520/1c374294-e742-4df6-9be9-5e91b665efe1)

- Ti·∫øp t·ª•c cho ho√°n v·ªã PC-1. Sau ƒë√≥ l·∫•y $L_0$ $XOR$ v·ªõi k·∫øt qu·∫£ v·ª´a c√≥. R·ªìi g√°n b·∫±ng $R_1$.

![image](https://github.com/MinhFanBoy/KCSC_tranning/assets/145200520/83470541-6257-4c8e-9556-53d87046adba)
> K·∫øt th√∫c h√†m F()

Sau ƒë√≥ ta ƒë·∫∑t:

+ $l_{i} = R _ {i - 1}$
+ $R_{i} = L_{i - 1} \oplus F(R_{i - 1}, k_i)$

L·∫•y ph·∫ßn $L _ {i}, R _ {i}$ ti·∫øp t·ª•c th·ª±c h√†m nh∆∞ tr√™n.

> Sau 16 v√≤ng

Ti·∫øp t·ª•c l√†m nh∆∞ v·∫≠y trong 16 v√≤ng. R·ªìi cho qua ho√°n vi IP(-1) th√¨ ta s·∫Ω c√≥ dc ciphertext.

![image](https://github.com/MinhFanBoy/KCSC_tranning/assets/145200520/60b91532-f0b8-4f12-95b5-27fa87306ef0)


V·∫≠y ta c√≥:
+ $l_{i} = R _ {i - 1}$
+ $R_{i} = L_{i - 1} \oplus F(R_{i - 1}, k_i)$

c. Th√¥ng tin th√™m

+ DES c√≥ hi·ªáu ·ª©ng tuy·∫øt l·ªü m·∫°nh:
  + v·ªõi m·ªói m·ªôt bit plaintext b·ªã thay ƒë·ªïi c√≥ th·ªÉ thay ƒë·ªïi √≠t nh·∫•t 34 bit ·ªü ciphertext
  + M·ªói m·ªôt bit ·ªü Key b·ªã thay ƒë·ªïi khi·∫øn ciphertext thay ƒë·ªïi √≠t nh·∫•t 35 bit
+ V·ªõi kh√≥a th·∫≠t s·ª± ƒë∆∞·ª£c d√πng trong DES l√† 56( Thay v√¨ 64 nh∆∞ ƒë·∫ßu v√†o) th√¨ ƒë·ªÉ bruteforce t·∫•t c·∫£ key (gi·∫£ s·ª≠ m·ªói l·∫ßn gi·∫£i m√£ m·∫•t m·ªôt gi√¢y) th√¨ ta t·ªën h∆°n 1000 nƒÉm ƒë·ªÉ ho√†n th√†nh
+ Hi·ªán t·∫°i DES ƒë∆∞·ª£c xem l√† kh√¥ng an to√†n n·ªØa.

### 2. 3DES

a. T·ªïng quan v·ªÅ 3DES

+ C≈©ng l√† DES nh∆∞ng ƒë∆∞·ª£c m√£ h√≥a nhi·ªÅu l·∫ßn v·ªõi c√°c key kh√°c nhau.
+ Y√™u c·∫ßu ƒë·∫ßu v√†o v√† ƒë·∫ßu ra c≈©ng gi·ªëng nh∆∞ DES.
+ Tr√°nh ƒë∆∞·ª£c vi·ªác b·ªã bruteforce hay t·∫•n c√¥ng kh√°c.

b. 3DES

+ 2DES: Sau khi m√£ h√≥a l·∫ßn 1 ta l·∫•y ciphertext ƒë√≥ l√†m plaintext c·ªßa l·∫ßn 2 v√† m√£ h√≥a. Vi·ªác gi·∫£i m√£ th√¨ ta gi·∫£i m√£ v·ªõi tr√¨nh t·ª± ng∆∞·ª£c l·∫°i, l·∫•y ciphertext c·ªßa l·∫ßn m√£ h√≥a th·ª© 2 m√£ h√≥a tr∆∞·ªõc xong ti·∫øp t·ª•c m√£ h√≥a n√≥ l√† ta s·∫Ω c√≥ th√¥ng tin ban ƒë·∫ßu.

![image](https://github.com/MinhFanBoy/KCSC_tranning/assets/145200520/01b82852-8e66-4161-bdea-2747d6a66ab5)

+ 3DES: Ta th·ª±c hi√™n nh∆∞ sau: L·∫•y plaintext m√£ h√≥a v·ªõi $key_1$, gi·∫£i m√£ b·∫±ng $key_2$ xong r·ªìi ti·∫øp t·ª•c m√£ h√≥a b·∫±ng $key_1$.

![image](https://github.com/MinhFanBoy/KCSC_tranning/assets/145200520/2cf7808c-0bfa-4f6e-8f77-9faeb2029f6b)

c. Th√¥ng tin th√™m
+ 2DES ƒë√£ b·ªã ph√° v·ª° b·ªüi c√°c cu·ªôc t·∫•n c√¥ng v√¨ ƒë·ªô d√†i kh√≥a qu√° ng·∫Øn.
+ 3DES s·ª≠ d·ª•ng ba kh√≥a DES ƒë·ªÉ m√£ h√≥a d·ªØ li·ªáu, m·ªói kh√≥a c√≥ ƒë·ªô d√†i 56 bit. 3DES ƒë∆∞·ª£c coi l√† m·ªôt phi√™n b·∫£n an to√†n h∆°n c·ªßa DES v√† ƒë∆∞·ª£c s·ª≠ d·ª•ng r·ªông r√£i trong c√°c s·∫£n ph·∫©m m·∫≠t m√£ d√¢n s·ª±. 3DES c≈©ng ƒë∆∞·ª£c s·ª≠ d·ª•ng trong c√°c s·∫£n ph·∫©m b·∫£o m·∫≠t nh∆∞ th·∫ª t√≠n d·ª•ng v√† c√°c s·∫£n ph·∫©m b·∫£o m·∫≠t th√¥ng tin kh√°c

### 3. AES(advanced encryption standard)

a. T·ªïng quan
+ ƒê∆∞·ª£c ph√°t tri·ªÉn b·ªüi NIST nƒÉm 2001.
+ **AES (Advanced Encryption Standard)** l√† m·ªôt thu·∫≠t to√°n m√£ h√≥a kh·ªëi ƒë·ªëi x·ª©ng ƒë∆∞·ª£c s·ª≠ d·ª•ng r·ªông r√£i trong c√°c s·∫£n ph·∫©m b·∫£o m·∫≠t th√¥ng tin. Thu·∫≠t to√°n n√†y ƒë∆∞·ª£c thi·∫øt k·∫ø ƒë·ªÉ thay th·∫ø cho thu·∫≠t to√°n DES (Data Encryption Standard) c≈© h∆°n. AES s·ª≠ d·ª•ng k√≠ch th∆∞·ªõc kh·ªëi 128 bit v√† c√≥ ba k√≠ch th∆∞·ªõc kh√≥a kh√°c nhau: 128, 192 v√† 256 bit. AES ƒë∆∞·ª£c coi l√† m·ªôt trong nh·ªØng thu·∫≠t to√°n m√£ h√≥a ƒë·ªëi x·ª©ng an to√†n nh·∫•t hi·ªán nay.(Trong b√†i vi·∫øt n√†y ƒë·ªÉ d·ªÖ r√†ng hi·ªÉu v√† vi·∫øt th√¨ m√¨nh ch·ªâ vi·∫øt v·ªõi AES c√≥ k√≠ch th∆∞·ªõc kh√≥a l√† 128bit)

<picture>
  <img src="https://lilthawg29.files.wordpress.com/2021/06/image-2.png" width="30%" height="30%">
</picture>

+ V·ªõi plaintext = 128 bit, key = 128 bit, 192 bit, or 256 bit.
+ Trong khi m√£ h√≥a c√≥ c√°c kh√≥a m·ªü r·ªông ƒë∆∞·ª£c sinh ra t·ª´ chu tr√¨nh Rijndeal. H·∫ßu h·∫øt c√°c ph√©p to√°n trong AES ƒë·ªÅu ƒë∆∞·ª£c th·ª±c hi·ªán tr√™n tr∆∞·ªùng h·ªØu h·∫°n c·ªßa c√°c bytes. M·ªói kh·ªëi 128 bit dc chia th√†nh 4 c·ªôt v·ªõi m·ªói c·ªôt 16 bytes x·∫øp th√†nh m·ªôt ma tr·∫≠n 4x4, c√≤n d∆∞·ª£c g·ªçi l√† ma tr·∫≠n tr·∫°ng th√°i. T√πy thu·ªôc v√†o ƒë·ªô d√†i c·ªßa kh√≥a m√† ta c√≥ s·ªë l·∫ßn l·∫∑p trong m·ªôt v√≤ng kh√°c nhau.
+ G·ªìm hai b∆∞·ªõc ch√≠nh l√† B∆∞·ªõc sinh kh√≥a(key generated) v√† m√£ h√≥a(encrypt).

b. Chi ti·∫øt

+ T·ªïng qu√°t c·∫£ qu√° tr√¨nh m√£ h√≥a:

![image](https://github.com/MinhFanBoy/KCSC_tranning/assets/145200520/ce64b0f9-770b-4e2e-a453-142eea0b2f01)

+ Chi ti·∫øt h∆°n:

![image](https://github.com/MinhFanBoy/KCSC_tranning/assets/145200520/0348bb66-dd0c-4f9b-9904-1b150f9abf13)

+ C√°c b∆∞·ªõc ch√≠nh:
   + b1 : Kh·ªüi t·∫°o plaintext k·∫øt h·ª£p v·ªõi key th√¥ng qua addRoundKey
   + b2 : L·∫∑p m√£ h√≥a, s·ª≠ d·ª•ng k·∫øt qu·∫£ c·ªßa b∆∞·ªõc 1 r·ªìi th√¥ng qua 4 h√†m ch√≠nh.
   + b3 : Sau N - 1 v√≤ng, ta cho n√≥ qua 3 h√†m (b·ªè qua MixColumns) ƒë·ªÉ ho√†n th√†nh m√£ h√≥a.
  
+ C√≥ N v√≤ng l·∫∑p v√† c√≥ N-1 v√≤ng l·∫∑p ch√≠nh(1 -> N - 1).Ch·ªß y·∫øu th·ª±c hi·ªán c√°c h√†m sau:
   + Subbytes - thay th·∫ø c√°c bytes d·ªØ li·ªáu b·∫±ng bytes ph·ª•
   + Shift rows - d·ªãch v√≤ng d·ªØ li·ªáu
   + Mix columns - tr·ªôn d·ªØu li·ªáu
   + AddRoundKeys - ch√®n kh√≥a v√≤ng

+ H√†m shift rows: L√† ph√©p chuy·ªÉn ƒë·ªïi c√°c ph·∫ßn t·ª≠ trong h√†ng, n√≥ gi·ªØ nguy√™n h√†ng ƒë·∫ßu ti√™n c·ªßa ma tr·∫≠n tr·∫°ng th√°i. H√†ng th·ª© hai ƒë∆∞·ª£c d·ªãch chuy·ªÉn qua m·ªôt c·ªôt ·ªü b√™n tr√°i. H√†ng th·ª© ba ƒë∆∞·ª£c d·ªãch chuy·ªÉn hai c·ªôt, h√†ng th·ª© t∆∞ ƒë∆∞·ª£c d·ªãch chuy·ªÉn ba c·ªôt.

![image](https://github.com/MinhFanBoy/KCSC_tranning/assets/145200520/7ee52c17-7d56-4723-8db2-0a6c070bd4bf)

 
+ H√†m AddRoundKeys: H√†m n√†y s·∫Ω l·∫•y gi√° tr·ªã c·ªßa t·ª´ng ph·∫ßn t·ª≠ c·ªßa tr·∫°ng th√°i hi·ªán t·∫°i(plaintext ƒëang ƒë∆∞·ª£c m√£ h√≥a) v·ªõi t·ª´ng ph·∫ßn t·ª≠ t·∫°i v·ªã tr√≠ t∆∞∆°ng ·ª©ng c·ªßa key
  
![image](https://github.com/MinhFanBoy/KCSC_tranning/assets/145200520/411b7cc5-4ac4-44f7-942c-b65835dcaf39)

+ MixColums : H√†m n√†y thay ƒë·ªïi gi√° tr·ªã c·ªßa t·ª´ng c·ªôt b·∫±ng c√°ch nh√¢n v·ªõi ma tr·∫≠n. N√≥ c√≤n ƒë∆∞·ª£c g·ªçi l√† h√†m xtime(h√†m nh√¢n x). M√¨nh s·∫Ω gi·∫£i th√≠ch r√µ h√†m n√†y h∆°n ·ªü ph·∫ßn c∆° s·ªü to√°n h·ªçc.
  
<picture>
   <img src="https://lilthawg29.files.wordpress.com/2021/09/image-238.png?w=1024" width="70%" heigth="70%">
</picture>

+ SubBytes - m·ªói bytes c·ªßa state ƒë∆∞·ª£c thay th·∫ø b·∫±ng 1 bytes kh√°c tr√™n S-box
  - L√† qu√° tr√¨nh thay th·∫ø phi tuy·∫øn t√≠nh trong ƒë√≥ m·ªói bytes ƒë∆∞·ª£c thay th·∫ø b·∫±ng m·ªôt bytes kh√°c trong b·∫£ng tra
  - S-box l√† b·∫≥ng 16 x 16 ch·ª©a ho√°n v·ªã c·ªßa 256 k√Ω t·ª±
  - M·ªói bytes tr·∫°ng th√°i ƒë∆∞·ª£c thay th·∫ø b·ªüi 4 bit tr√°i v√† c·ªôt x√°c ƒë·ªãnh b·ªüi 4 bit ph·∫£i, VD: 6D s·∫Ω ƒë∆∞·ª£c thay th·∫ø b·ªüi S-box[6][D]
  - H·ªôp th·∫ø s-box ƒë∆∞·ª£c x√¢y d·ª±ng tr√™n ph√©p bi·∫øn ƒë·ªïi phi tuy·∫øn (c√°i n√†y kh√¥ng hi·ªÉu l·∫Øm)
    
c. Qu√° tr√¨nh t·∫°o kh√≥a m·ªü r·ªông

+ KeyExpansion: ƒê∆∞·ª£c th·ª±c hi·ªán theo h√†m quy n·∫°p.
+ V·ªõi Rcon = [01, 02, 04, 08, 10, 20, 40, 80, 1b, 36]
+ V·ªõi 128 bit key ta c√≥ ƒë∆∞·ª£c 16 bytes key, t·ª´ ƒë√≥ chia ra l√†m 4 ƒëo·∫°n key ph·ª• ƒë∆∞·ª£c goi l√† word ƒë∆∞·ª£c ƒë√°nh s·ªë t·ª´ 0 ƒë·∫øn 3.

![image](https://github.com/MinhFanBoy/KCSC_tranning/assets/145200520/35e4d27e-75fd-48f8-9007-36a84d1fbdc2)

+ c√°c word sau ƒë∆∞·ª£c t√≠nh theo c√¥ng th·ª©c nh∆∞ sau:
  + $word_i = word_{i - 1} \oplus word_{i - 4}$ v·ªõi m·ªçi $4 \le t < 44$ v√† i kh√¥ng ph·∫£i l√† b·ªôi c·ªßa 4
  + $word_i = g(word_{i - 1}) \oplus word_{i - 4}$ v·ªõi i l√† b·ªôi c·ªßa 4

<picture>
   <img src="https://lilthawg29.files.wordpress.com/2021/09/image-244.png?w=1024" width="70%" heigth="70%">
</picture>

+ H√†m g() l√† h√†m thay ƒë·ªïi g·ªìm c√°c b∆∞·ªõc d·ªãch tr√°i, ƒë·ªïi ch·ªó v·ªõi s_box v√† xor v·ªõi Rcon:
  + D·ªãch tr√°i 1 ƒë∆°n v·ªã c√°c ph·∫ßn t·ª≠ c·ªßa word
  + ƒê·ªïi ch·ªó v·ªõi s_box(h√†m n√£y c≈©ng gi·ªëng h√†n subbytes trong h√†m ch√≠nh)
  + Xor v·ªõi Rcon[i/4] v√¨ i khi n√†y chi h·∫øt cho 4.
    
d. C∆° s·ªü to√°n h·ªçc c·ªßa AES
  + Trong AES c√°c ph√©p to√°n ƒë∆∞·ª£c th·ª±c hi·ªán tr√™n tr∆∞·ªùng h·ªØu h·∫°n GF(2^8)
  + Ph√©p c·ªông: $A( a_1, a_2, a_3,..), B( b_1, b_2, b_3, ...)$ => $C = A + B = (c_1, c_2, c_3, ...)$ v·ªõi $c_i = (a_i + b_i) \pmod{2}$
  + Ph√©p nh√¢n: ƒê∆∞·ª£c th∆∞c hi·ªán tr√™n tr∆∞·ªùng GF(2^8) b·∫±ng c√°ch nh√¢n 2 ƒëa th·ª©c trong modul b·∫•t kh·∫£ quy m(x).Trong AES $m(x) = x^8 + x^4 + x^3 + x + 1$
  + Ph√©p xtime: (l√† ph√©p nh√¢n v·ªõi x) ƒë·ªçc k hi·ªÉu j c·∫£ hic

e. ƒê·ªô an to√†n
  + t√≠nh ch·∫•t ph·ª©c t·∫°p c·ªßa bi·ªÉu th·ª©c s-box tr√™n $GF(2^8)$ c√πng v·ªõi hi·ªáu ·ª©ng khu·∫øch t√°n gi√∫p cho thu·∫≠t to√°n kh√¥ng b·ªã ph√¢n t√≠ch b·∫±ng ph∆∞∆°ng ph√°p n·ªôi suy
  + Rcon kh√°c nhau h·∫°n ch·∫ø t√≠nh ƒë·ªëi x·ª©ng
  + T√≠nh ch·∫•t phi tuy·∫øn t√≠nh
  + C√°c c·∫•u tr√∫c h√≥a gi·∫£i m√£ kh√°c nhau h·∫°n ch·∫ø ƒë∆∞·ª£c kh√≥a y·∫øu

### 4. PKCS#7

C√°c lo·∫°i m·ªü r·ªông th∆∞·ªùng ƒë∆∞·ª£c d√πng ƒë·ªÉ k√Ω hi·ªáu: $.p7b, .p7s, .p7m, .p7c, .p7r$

Ph√°t tri·ªÉn b·ªüi	RSA Security, 1 March 1998

PKCS#7 l√† m·ªôt chu·∫©n c√∫ ph√°p cho vi·ªác l∆∞u tr·ªØ d·ªØ li·ªáu ƒë∆∞·ª£c k√Ω v√†/ho·∫∑c m√£ h√≥a. N√≥ l√† m·ªôt trong c√°c chu·∫©n thu·ªôc h·ªç chu·∫©n m√£ h√≥a kh√≥a c√¥ng khai (PKCS) ƒë∆∞·ª£c t·∫°o ra b·ªüi RSA Laboratories. Chu·∫©n n√†y ƒë∆∞·ª£c s·ª≠ d·ª•ng r·ªông r√£i trong c√°c ·ª©ng d·ª•ng b·∫£o m·∫≠t th√¥ng tin, v√≠ d·ª• nh∆∞ ƒë·ªÉ l∆∞u tr·ªØ ch·ª©ng ch·ªâ v√† danh s√°ch thu h·ªìi ch·ª©ng ch·ªâ (CRL). Phi√™n b·∫£n m·ªõi nh·∫•t c·ªßa chu·∫©n PKCS#7 l√† 1.5 v√† c√≥ th·ªÉ ƒë∆∞·ª£c t√¨m th·∫•y trong RFC 2315. Chu·∫©n n√†y cho ph√©p ƒë·ªá quy, thu·ªôc t√≠nh, v√† c√°c lo·∫°i n·ªôi dung kh√°c nhau, ch·∫≥ng h·∫°n nh∆∞ d·ªØ li·ªáu, d·ªØ li·ªáu ƒë√£ k√Ω, d·ªØ li·ªáu ƒë√£ g·ª≠i v√† d·ªØ li·ªáu ƒë√£ k√Ω v√† g·ª≠i. N√≥ c≈©ng cho ph√©p l∆∞u tr·ªØ ch·ª©ng ch·ªâ v√†/ho·∫∑c danh s√°ch thu h·ªìi ch·ª©ng ch·ªâ (CRL)

PKCS#7 ƒë∆∞·ª£c l∆∞u tr·ªØ d∆∞·ªõi d·∫°ng DER ho·∫∑c PEM. D·∫°ng PEM c≈©ng gi·ªëng nh∆∞ DER nh∆∞ng ƒë∆∞·ª£c m√£ h√≥a Base64 v√† c√≥ ƒë·∫∑t ‚Äë‚Äë‚Äë‚Äë‚ÄëBEGIN PKCS7‚Äë‚Äë‚Äë‚Äë‚Äë, ‚Äë‚Äë‚Äë‚Äë‚ÄëEND PKCS7‚Äë‚Äë‚Äë‚Äë‚Äë ƒë·ªÉ ph√¢n bi·ªát.

### 5. PKCS#7 Padding

PKCS#7 Padding l√† m·ªôt chu·∫©n c√∫ ph√°p ƒë∆∞·ª£c s·ª≠ d·ª•ng trong c√°c thu·∫≠t to√°n m√£ h√≥a kh·ªëi nh∆∞ DES v√† AES ƒë·ªÉ ƒë·∫£m b·∫£o r·∫±ng d·ªØ li·ªáu ƒë∆∞·ª£c m√£ h√≥a c√≥ ƒë·ªô d√†i b·∫±ng b·ªôi s·ªë c·ªßa k√≠ch th∆∞·ªõc kh·ªëi. N√≥ ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a trong RFC 5652 v√† ƒë∆∞·ª£c s·ª≠ d·ª•ng r·ªông r√£i trong c√°c ·ª©ng d·ª•ng b·∫£o m·∫≠t th√¥ng tin. Khi d·ªØ li·ªáu c·∫ßn ƒë∆∞·ª£c m√£ h√≥a kh√¥ng ph·∫£i l√† b·ªôi s·ªë c·ªßa k√≠ch th∆∞·ªõc kh·ªëi, PKCS#7 Padding s·∫Ω th√™m v√†o c√°c byte padding ƒë·ªÉ ƒë·∫£m b·∫£o r·∫±ng d·ªØ li·ªáu c√≥ ƒë·ªô d√†i b·∫±ng b·ªôi s·ªë c·ªßa k√≠ch th∆∞·ªõc kh·ªëi. C√°c byte padding n√†y c√≥ gi√° tr·ªã b·∫±ng s·ªë l∆∞·ª£ng byte padding ƒë∆∞·ª£c th√™m v√†o. V√≠ d·ª•, n·∫øu c·∫ßn th√™m 6 byte padding, m·ªói byte ƒë√≥ s·∫Ω c√≥ gi√° tr·ªã l√† 0x06 . Tuy nhi√™n, n·∫øu ƒë·ªô d√†i c·ªßa d·ªØ li·ªáu c·∫ßn ƒë∆∞·ª£c m√£ h√≥a ƒë√£ l√† b·ªôi s·ªë c·ªßa k√≠ch th∆∞·ªõc kh·ªëi, PKCS#7 Padding v·∫´n s·∫Ω th√™m v√†o c√°c byte padding ƒë·ªÉ tr√°nh nh·∫ßm l·∫´n.

V√≠ d·ª•: M·ªôt lo·∫°i m√£ kh√≥a c·∫ßn c√≥ ƒë·∫ßu v√†o l√† 4 bytes th√¨ ta s·∫Ω bu·ªôc ph·∫£i nh·∫≠p ƒë·ªß 4 bytes v√†o th√¨ n√≥ m·ªõi c√≥ th·ªÉ ƒë∆∞·ª£c m√£ h√≥a. Trong tr∆∞·ªùng h·ª£p kh√¥ng ƒë·ªß 4 bytes th√¨ ta c√≥ th·ªÉ d√πng PKCS#7 ƒë·ªÉ padding n√≥ nh∆∞ sau: input : \x11\x11\x11, th√¨ sau khi padding ta s·∫Ω c√≥ output: \x11\x11\x11\x01. T∆∞∆°ng t·ª± v·ªõi c√°c tr∆∞·ªùng h·ª£p kh√°c.(N·∫øu input kh√¥ng c√≥ g√¨ th√¨ n√≥ s·∫Ω tr·∫£ v·ªÅ b·ªôi s·ªë c·ªßa 4 bytes ƒë·ªÉ tr√°nh nh·∫ßm l·∫´n)

### 6. Modes of block cipher

#### 6.1. ECB
+ C√°c th√¥ng tin s·∫Ω ƒë∆∞·ª£c chia th√†nh c√°c kh·ªëi ƒë·ªôc l·∫≠p, sau ƒë√≥ m√£ t·ª´ng kh·ªëi ri√™ng l·∫ª v·ªõi nhau
+ C√°c Kh·ªëi ƒë∆∞·ª£c m√£ ƒë·ªôc l·∫≠p v·ªõi c√°c kh·ªëi kh√°c $C_i = E(P_i)$, do v·∫≠y n√≥ ƒë∆∞·ª£c d√πng ƒë·ªÉ truy·ªÅn an to√†n t·ª´ng gi√° tr·ªã ri√™ng l·∫ª
+ T√≠nh ch·∫•t:
    - C√°c kh·ªëi m√£ nh∆∞ nhau s·∫Ω c√≥ b·∫£n m√£ gi·ªëng nhau (d∆∞·ªõi c√πng m·ªôt kh√≥a)
    - S·ª± ph·ª• thu·ªôc kh√¥ng c√≥ n√™n vi·ªác thay ƒë·ªïi s·∫Øp x·∫øp c√°c block v·ªõi nhau th√¨ c√°c b·∫£n r√µ c≈©ng ph·∫£i ƒë∆∞·ª£c s·∫Øp x·∫øp l·∫°i t∆∞∆°ng ·ª©ng
    - T√≠nh lan sai : Khi m·ªôt hay nhi·ªÅu bit sai trong m·ªôt kh·ªëi ƒë∆°n l·∫ª th√¨ n√≥ ch·ªâ ·∫£nh h∆∞·ªüng trong kh·ªëi ƒë√≥ v√† kh√¥ng ·∫£nh h∆∞·ªüng t·ªõi c√°c kh·ªëi kh√°c
    - N√≥ c√≥ th·ªÉ s·ª© l√Ω nhi·ªÅu kh·ªëi song song
   
![image](https://github.com/MinhFanBoy/KCSC_tranning/assets/145200520/2532b32e-c5d0-41af-8c30-53ab655430e3)

#### 6.2. CBC
+ M·∫©u tin ƒë∆∞·ª£c chia th√†nh c√°c kh·ªëi
+ C√°c block s·∫øp th√†nh d√£y trong qu√° tr√¨nh m√£ h√≥a, gi·∫£i m√£
+ S·ª≠ d·ª•ng vector IV ƒë·ªÉ b·∫Øt ƒë·∫ßu qu√° tr√¨nh $c_i = e(p_i xor c_i-1), c_-1 = IV$
+ T√≠nh ch·∫•t :
  - c√°c b·∫£n r√µ gi·ªëng nhau c≈©ng ch∆∞a ch·∫Øc cho ra b·∫£n m√£ gi·ªëng nhau. v√¨ n√≥ c√≤n ph·ª• thu·ªôc v√†o IV
  - S·ª± ph·ª• thu·ªôc m√≥c x√≠ch: c∆° ch·∫ø m√£ h√≥a l√†m cho b·∫£n m√£ $c_i$ ph·ª• thu·ªôc v√†o b·∫£n m√£ $c_{i-1}$ n√™n n·∫øu thay ƒë·ªïi c√°ch s·∫Øp x·∫øp c√°c b·∫£n s·∫Ω r·∫•t kh√≥ t·∫•n c√¥ng. Vi·ªác gi·∫£i m√£ kh·ªëi n√†y th√¨ c≈©ng ƒë√≤i h·ªèi ph·∫£i gi·∫£i ƒë√∫ng kh·ªëi tr∆∞·ªõc n√≥ n√≥
  - T√≠nh lan sai: Khi sai m·ªôt bit trong kh·ªëi m√£ th√¨ vi·ªác gi·∫£i, m√£ t·∫•t c·∫£ c√°c kh·ªëi sau n√≥ s·∫Ω b·ªã sai

 
![image](https://github.com/MinhFanBoy/KCSC_tranning/assets/145200520/072a2115-17b7-4a53-b4c3-0c4e5c4604dd)



#### 6.3. CFB
+ Th√¥ng tin khi ƒëi v√†o s·∫Ω dc chia th√†nh c√°c kh·ªëi
+ c√°c b·∫£n r√µ dc s·∫Øp x·∫øp n√™n khi gi·∫£i m√£ cx y√™u c·∫ßu th·ª© t·ª± c√°c b·∫£n m√£ ph·∫£i ƒë√∫ng.
+ $c_i = p_i \oplus e(k, c_{i-1})$ v·ªõi $c_{-1} = IV$
+ T√≠nh ch·∫•t:
  - C√°c b·∫£n r√µ gi·ªëng nhau: gi·ªëng nh∆∞ CBC
  - S·ª± ph·ª• thu·ªôc m√≥c x√≠ch: gi·ªëng nh∆∞ CBC
  - T√≠nh lan sai: gi·ªëng nh∆∞ CBC
  - Kh√¥ng th·ªÉ th·ª±c hi√™n qu√° tr√¨nh gi·∫£i m√£ song song v√¨ x·ª≠ l√Ω c·ªßa kh·ªëi sau ph·ª• thu·ªôc v√†o kh·ªëi tr∆∞·ªõc

![image](https://github.com/MinhFanBoy/KCSC_tranning/assets/145200520/f2a5c50f-1fce-44c5-85d6-56955693f674)


    
#### 6.4. OFB
+ Nh√¨n chung th√¨ c≈©ng gi·ªëng c√°c mode tr∆∞·ªõc nh∆∞ng kh√°c t√Ω: $c_i = p_1 \oplus e_i(k, c_{i - 1})$ v·ªõi $c_{-1} = IV$
+ Khi m√£ h√≥a c·ªßa m·ªôt kh·ªëi b·ªã sai c≈©ng kh√¥ng ·∫£nh h∆∞·ªüng t·ªõi c√°c kh·ªëi kh√°c
+ T√≠nh b·∫£o m·∫≠t cao, c√≥ th·ªÉ m√£ h√≥a ƒë∆∞·ª£c nhi·ªÅu kh·ªëi c√πng m·ªôt l√∫c n√™n ƒë∆∞·ª£c t·∫≠n d·ª•ng trong vi·ªác truy·ªÅn t·∫£i √¢m thanh 

![image](https://github.com/MinhFanBoy/KCSC_tranning/assets/145200520/c261a31d-11d5-4977-b0c2-953a9641f9a2)

  
#### 6.5. CTR
+ T·∫°o ra m·ªôt b·ªô ƒë·∫øm b·∫±ng vƒÉn b·∫£n g·ªëc, g·ªçi l√† R(). M·ªói kh·ªëi nh·∫≠n ƒë∆∞·ª£c m·ªôt b·ªô ƒë·∫øm v√† m·ªôt kh√≥a ri√™ng ƒë·ªÉ t·∫°o ra kh·ªëi ƒë·∫ßu ra
+ Kh·ªëi ƒë·∫ßu ra ƒë∆∞·ª£c xor v·ªõi b·∫£n r√µ ƒë·ªÉ t·∫°o th√†nh b·∫£n m√£
  + $c_i = e(R_i) xor p_i$
  + $p_i = e(R_i) xor c_i$
+ T√≠nh ch·∫•t:
  - C√≥ hi·ªáu qu·∫£ cao, th·ª±c hi·ªán gi·∫£i m√£ ho·∫∑c m√£ h√≥a tr√™n nhi·ªÅu block
  - c√≥ t√≠nh an ninh cao kh√¥ng k√©m c√°c mode kh√°c khi th·ª±c hi·ªán ƒë√∫ng c√°ch
  - ƒë∆°n gi·∫£n v·ªÅ m·∫∑t c·∫•u tr√∫c
  - c√°c bi·∫øn ƒë·∫øm ph·∫£i c√≥ y√™u c·∫ßu kh√¥ng ƒë∆∞·ª£c l·∫∑p l·∫°i ƒë·ªÉ tr√°nh kh√≥a y·∫øu

## III. Attack

### 1. Man in the middle.

Man in the middle (MITM) hay c√≤n ƒë∆∞·ª£c g·ªçi l√† t·∫•n c√¥ng trung gian ƒë∆∞·ª£c hellman v√† mackey ch·ªâ ra nƒÉm 1977.
N√≥ l√† m·ªôt ki·ªÉu t·∫•n c√¥ng m·∫°ng nh·∫±m ch·∫∑ to√†n b·ªô th√¥ng tin c·ªßa hai b√™n v√† m·∫°o danh ƒë·ªÉ c√≥ th·ªÉ l√†m ch·ªß nhi·ªÅu th√¥ng tin nh·∫°y c·∫£m theo √Ω c·ªßa k·∫ª t·∫•n c√¥ng. AES, DES v√† nhi·ªÅu m√£ h√≥a kh√°c ƒë∆∞·ª£c coi l√† kh√¥ng an to√†n tr∆∞·ªõc ki·ªÉu t·∫•n c√¥ng n√†y. ƒê·ªÉ b·∫£o v·ªá tr∆∞·ªõc cu·ªôc t·∫•n c√¥ng n√†y ta c·∫ßn ph·∫£i m√£ h√≥a th√¥ng tin v√† k√Ω tr∆∞·ªõc khi g·ª≠i ƒë·ªìng th·ªùi c√≥ th·ªÉ d√πng nhi·ªÅu giao th·ª©c b·∫£o m·∫≠t kh√°c nh·∫±n tƒÉng t√≠nh an to√†n.

Tr√™n th·ª±c t·∫ø m√£ h√≥a 2DES kh√¥ng th·∫≠t s·ª± l√†m t·∫±ng s·ªë key kh√≥a l√™n $2 ^ 112$ . ·ª®ng d·ª•ng ph√¢n t√≠ch m·∫≠t m√£ (1996), ƒë∆∞·ª£c xu·∫•t b·∫£n tr√™n T·∫°p ch√≠ M·∫≠t m√£ h·ªçc, 1999. H·ªç tuy√™n b·ªë r·∫±ng 2DES cung c·∫•p "ch·ªâ nhi·ªÅu h∆°n 17 bit b·∫£o m·∫≠t" so v·ªõi DES (con s·ªë ƒë√≥ v·∫´n c√≥ th·ªÉ cao h∆°n m·ªôt trƒÉm ngh√¨n l·∫ßn). N√≥ v·∫´n c√≤n r·∫•t l·ªõn n√™n n·∫øu t·∫•n c√¥ng b·∫±ng MITM th√¨ ta s·∫Ω gi·∫£m th·ªùi t·∫•n c√¥ng xu·ªëng $2 ^ 57$ t·ª©c ch·ªâ g·∫•p ƒë√¥i so v·ªõi DES.

Gi·∫£ s·ª≠ b·∫°n l√† nh√† gi·∫£i m√£ c√≥ quy·ªÅn truy c·∫≠p v√†o vƒÉn b·∫£n thu·∫ßn t√∫y v√† vƒÉn b·∫£n ƒë∆∞·ª£c m√£ h√≥a. M·ª•c ƒë√≠ch c·ªßa b·∫°n l√† kh√¥i ph·ª•c kh√≥a b√≠ m·∫≠t. Gi·∫£ s·ª≠ AAA (b·∫£n r√µ) -> XXX (Sau l·∫ßn m√£ h√≥a ƒë·∫ßu ti√™n) -> ZZZ (sau l·∫ßn m√£ h√≥a th·ª© 2).

B·∫Øt ƒë·∫ßu v·ªõi AAA v√† th·ª≠ t·∫•t c·∫£ $2 ^ 56$ c√°ch k·∫øt h·ª£p kh√≥a b√≠ m·∫≠t b·∫±ng c√°ch m√£ h√≥a AAA. ƒêi·ªÅu n√†y s·∫Ω cung c·∫•p cho b·∫°n m·ªôt danh s√°ch l·ªõn c√°c gi√° tr·ªã c√≥ th·ªÉ c√≥ cho XXX. Ti·∫øp theo, b·∫°n l·∫•y ZZZ v√† th·ª≠ t·∫•t c·∫£ 256 t·ªï h·ª£p kh√≥a b√≠ m·∫≠t b·∫±ng c√°ch gi·∫£i m√£ ZZZ. ƒêi·ªÅu n√†y s·∫Ω cung c·∫•p cho b·∫°n m·ªôt danh s√°ch l·ªõn c√°c gi√° tr·ªã c√≥ th·ªÉ c√≥ cho XXX.
B√¢y gi·ªù h√£y th·ª±c hi·ªán tra c·ª©u ƒë∆°n gi·∫£n gi·ªØa hai danh s√°ch ƒë·ªÉ t√¨m gi√° tr·ªã ph√π h·ª£p. Ngay khi b·∫°n th·∫•y gi√° tr·ªã XXX ph√π h·ª£p trong c·∫£ hai danh s√°ch, b·∫°n ƒë√£ t√¨m ra kh√≥a b√≠ m·∫≠t. V√¨ v·∫≠y, ƒëi·ªÅu n√†y c√≥ nghƒ©a l√† v·ªõi n·ªó l·ª±c $2 ^ 57$ kh√≥a, b·∫°n ƒë√£ ph√° v·ª° ƒë∆∞·ª£c m√£ h√≥a. EZ attack üò≤

### 2. Padding Oracle
   
**Padding Oracle** l√† m·ªôt lo·∫°i t·∫•n c√¥ng m·∫≠t m√£ khai th√°c x√°c th·ª±c ph·∫ßn ƒë·ªám c·ªßa th√¥ng ƒëi·ªáp m·∫≠t m√£ ƒë·ªÉ gi·∫£i m√£ vƒÉn b·∫£n m√£ h√≥a. Cu·ªôc t·∫•n c√¥ng n√†y ch·ªß y·∫øu li√™n quan ƒë·∫øn **ch·∫ø ƒë·ªô CBC** ho·∫°t ƒë·ªông ƒë∆∞·ª£c s·ª≠ d·ª•ng trong m·∫≠t m√£ kh·ªëi. Trong ƒë√≥ ‚Äúoracle‚Äù (th∆∞·ªùng l√† m√°y ch·ªß) r√≤ r·ªâ d·ªØ li·ªáu v·ªÅ vi·ªác li·ªáu ph·∫ßn ƒë·ªám c·ªßa tin nh·∫Øn ƒë∆∞·ª£c m√£ h√≥a c√≥ ch√≠nh x√°c hay kh√¥ng. D·ªØ li·ªáu nh∆∞ v·∫≠y c√≥ th·ªÉ cho ph√©p nh·ªØng k·∫ª t·∫•n c√¥ng gi·∫£i m√£ (v√† ƒë√¥i khi m√£ h√≥a) tin nh·∫Øn th√¥ng qua oracle b·∫±ng c√°ch s·ª≠ d·ª•ng kh√≥a c·ªßa oracle m√† kh√¥ng c·∫ßn bi·∫øt kh√≥a m√£ h√≥a.
Vi·ªác tri·ªÉn khai ti√™u chu·∫©n c·ªßa gi·∫£i m√£ CBC trong m·∫≠t m√£ kh·ªëi l√† gi·∫£i m√£ t·∫•t c·∫£ c√°c kh·ªëi b·∫£n m√£, x√°c th·ª±c ph·∫ßn ƒë·ªám, x√≥a ph·∫ßn ƒë·ªám PKCS7 v√† tr·∫£ v·ªÅ vƒÉn b·∫£n thu·∫ßn t√∫y c·ªßa tin nh·∫Øn. N·∫øu m√°y ch·ªß tr·∫£ v·ªÅ l·ªói ‚Äúƒë·ªám kh√¥ng h·ª£p l·ªá‚Äù thay v√¨ l·ªói chung ‚Äúgi·∫£i m√£ kh√¥ng th√†nh c√¥ng‚Äù, k·∫ª t·∫•n c√¥ng c√≥ th·ªÉ s·ª≠ d·ª•ng m√°y ch·ªß nh∆∞ m·ªôt oracle ƒë·ªám ƒë·ªÉ gi·∫£i m√£ (v√† ƒë√¥i khi m√£ h√≥a) message.

<picture>
   <img src="https://i.imgur.com/BW82maM.png">
</picture>

## IV. Write up

### 1. Keyed Permutations

---

**_TASK:_**

What is the mathematical term for a one-to-one correspondence?

---

Trong to√°n h·ªçc thu·∫≠t ng·ªØ m·ªôt-m·ªôt l√†m ta nh·ªõ t·ªõi song √°nh, khi n√≥ h√†m song √°nh ta c√≥ th·ªÉ ho√†n to√†n t√¨m ƒë∆∞·ª£c h√†m ngh·ªãch ƒë·∫£o c·ªßa n√≥ m·ªôt y√™u c·∫ßu quan tr·ªçng trong vi·ªác gi·∫£i, m√£ .

> crypto{bijection}

### 2. Resisting Bruteforce

---

**_TASK:_**

What is the name for the best single-key attack against AES?

---

H·ªèi google l√† ta c√≥ ngay ƒë√°p √°n. The best publicly known single-key attack on AES is the **biclique attack** which is still the best publicly known single-key attack on AES as of April 2019. The computational complexity of the attack is, and for AES128, AES192 and AES256, respectively. It is the only publicly known single-key attack on AES that attacks the full number of rounds¬≤.

> crypto{biclique}

### 3. Structure of AES

---

**_TASK:_**

Included is a bytes2matrix function for converting our initial plaintext block into a state matrix. Write a matrix2bytes function to turn that matrix back into bytes, and submit the resulting plaintext as the flag.

**_File:_**

```py
def bytes2matrix(text):
    """ Converts a 16-byte array into a 4x4 matrix.  """
    return [list(text[i:i+4]) for i in range(0, len(text), 4)]

def matrix2bytes(matrix):
    """ Converts a 4x4 matrix into a 16-byte array.  """
    ????

matrix = [
    [99, 114, 121, 112],
    [116, 111, 123, 105],
    [110, 109, 97, 116],
    [114, 105, 120, 125],
]

print(matrix2bytes(matrix))
```

---

B√†i n√†y ta ch·ªâ ph·∫£i ho√†n th√†nh n·ªët h√†m matrix to bytes n√™n c≈©ng kh√° d·ªÖ.

```py
def matrix2bytes(matrix):
    """ Converts a 4x4 matrix into a 16-byte array.  """
    return bytes(matrix[0] + matrix[1] + matrix[2] + matrix[3])

```
> crypto{inmatrix}

### 4. Round Keys

---

**_TASK:_**

Complete the add_round_key function, then use the matrix2bytes function to get your next flag.

**_FILE:_**
```py
state = [
    [206, 243, 61, 34],
    [171, 11, 93, 31],
    [16, 200, 91, 108],
    [150, 3, 194, 51],
]

round_key = [
    [173, 129, 68, 82],
    [223, 100, 38, 109],
    [32, 189, 53, 8],
    [253, 48, 187, 78],
]


def add_round_key(s, k):
    ???


print(add_round_key(state, round_key))


```
---

Ho√†n th√†nh n·ªët h√†m n√†y b·∫±ng l√Ω thuy·∫øt ta v·ª´a h·ªçc, l·∫•y t·ª´ng ph·∫ßn t·ª≠ c·ªßa tr·∫°ng th√°i  v·ªõi ph·∫ßn t·ª≠ ·ªü v·ªã tr√≠ t∆∞∆°ng ·ª©ng c·ªßa tr·∫°ng th√°i l√† ok 10 ƒëi·ªÉm.

```py
state = [
    [206, 243, 61, 34],
    [171, 11, 93, 31],
    [16, 200, 91, 108],
    [150, 3, 194, 51],
]

round_key = [
    [173, 129, 68, 82],
    [223, 100, 38, 109],
    [32, 189, 53, 8],
    [253, 48, 187, 78],
]


def add_round_key(s, k):
    return [[s[i][j] ^ k[i][j] for j in range(4)] for i in range(4)]

def matrix2bytes(matrix):
    """ Converts a 4x4 matrix into a 16-byte array.  """
    return bytes(matrix[0] + matrix[1] + matrix[2] + matrix[3])


print(matrix2bytes(add_round_key(state, round_key)))

```

> crypto{r0undk3y}

### 5. Confusion through Substitution

---

**_TASK:_**

To make the S-box, the function has been calculated on all input values from 0x00 to 0xff and the outputs put in the lookup table.

Implement sub_bytes, send the state matrix through the inverse S-box and then convert it to bytes to get the flag.

**_File:_**
```py
s_box = (
    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16,
)

inv_s_box = (
    0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
    0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
    0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
    0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
    0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
    0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
    0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
    0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
    0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
    0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
    0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
    0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
    0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
    0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
    0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
    0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D,
)

state = [
    [251, 64, 182, 81],
    [146, 168, 33, 80],
    [199, 159, 195, 24],
    [64, 80, 182, 255],
]


def sub_bytes(s, sbox=s_box):
    ????

print(matrix2bytes(sub_bytes(state, sbox=inv_s_box)))
```
---

Nh·ªõ l·∫°i ki·∫øn th·ª©c v·ª´a ƒë·ªçc, ta c√≥: ch·ªâ c·∫ßn thay th·∫ø gi√° tr·ªã c·ªßa t·ª´ng tr·∫°ng th√°i v√†o v·ªã tr√≠ t∆∞∆°ng ·ª©ng c·ªßa xbox.

```py
s_box = (
    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16,
)

inv_s_box = (
    0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
    0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
    0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
    0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
    0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
    0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
    0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
    0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
    0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
    0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
    0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
    0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
    0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
    0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
    0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
    0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D,
)

state = [
    [251, 64, 182, 81],
    [146, 168, 33, 80],
    [199, 159, 195, 24],
    [64, 80, 182, 255],
]


def sub_bytes(s, sbox=s_box):
    return [[sbox[y] for y in x] for x in state]
def matrix2bytes(matrix):
    """ Converts a 4x4 matrix into a 16-byte array.  """
    return bytes(matrix[0] + matrix[1] + matrix[2] + matrix[3])


print(matrix2bytes(sub_bytes(state, sbox=inv_s_box)))
```

> crypto{l1n34rly}

### 6. Diffusion through Permutation

---

**_TASK:_**


We've provided code to perform MixColumns and the forward ShiftRows operation. After implementing inv_shift_rows, take the state, run inv_mix_columns on it, then inv_shift_rows, convert to bytes and you will have your flag.

Challenge files:
  - diffusion.py

**_FILE:_**
```py
def shift_rows(s):
    s[0][1], s[1][1], s[2][1], s[3][1] = s[1][1], s[2][1], s[3][1], s[0][1]
    s[0][2], s[1][2], s[2][2], s[3][2] = s[2][2], s[3][2], s[0][2], s[1][2]
    s[0][3], s[1][3], s[2][3], s[3][3] = s[3][3], s[0][3], s[1][3], s[2][3]


def inv_shift_rows(s):
    ???

# learned from http://cs.ucsb.edu/~koc/cs178/projects/JT/aes.c
xtime = lambda a: (((a << 1) ^ 0x1B) & 0xFF) if (a & 0x80) else (a << 1)


def mix_single_column(a):
    # see Sec 4.1.2 in The Design of Rijndael
    t = a[0] ^ a[1] ^ a[2] ^ a[3]
    u = a[0]
    a[0] ^= t ^ xtime(a[0] ^ a[1])
    a[1] ^= t ^ xtime(a[1] ^ a[2])
    a[2] ^= t ^ xtime(a[2] ^ a[3])
    a[3] ^= t ^ xtime(a[3] ^ u)


def mix_columns(s):
    for i in range(4):
        mix_single_column(s[i])


def inv_mix_columns(s):
    # see Sec 4.1.3 in The Design of Rijndael
    for i in range(4):
        u = xtime(xtime(s[i][0] ^ s[i][2]))
        v = xtime(xtime(s[i][1] ^ s[i][3]))
        s[i][0] ^= u
        s[i][1] ^= v
        s[i][2] ^= u
        s[i][3] ^= v

    mix_columns(s)


state = [
    [108, 106, 71, 86],
    [96, 62, 38, 72],
    [42, 184, 92, 209],
    [94, 79, 8, 54],
]
```
---

B√†i n√†y ta ch·ªâ c·∫ßn ƒë·ªïi ch·ªó gi·ªØa c√°c ph·∫ßn t·ª≠ c·ªßa ma tr·∫≠n l√† xong, l√†m ng∆∞·ª£c l·∫°i. Nh·ªõ cho th√™m h√†m return(:>)
```py
def shift_rows(s):
    s[0][1], s[1][1], s[2][1], s[3][1] = s[1][1], s[2][1], s[3][1], s[0][1]
    s[0][2], s[1][2], s[2][2], s[3][2] = s[2][2], s[3][2], s[0][2], s[1][2]
    s[0][3], s[1][3], s[2][3], s[3][3] = s[3][3], s[0][3], s[1][3], s[2][3]
    return s

def inv_shift_rows(s):
    s[1][1], s[2][1], s[3][1], s[0][1] = s[0][1], s[1][1], s[2][1], s[3][1]
    s[2][2], s[3][2], s[0][2], s[1][2] = s[0][2], s[1][2], s[2][2], s[3][2]
    s[3][3], s[0][3], s[1][3], s[2][3] = s[0][3], s[1][3], s[2][3], s[3][3]
    return s


# learned from http://cs.ucsb.edu/~koc/cs178/projects/JT/aes.c
xtime = lambda a: (((a << 1) ^ 0x1B) & 0xFF) if (a & 0x80) else (a << 1)


def mix_single_column(a):
    # see Sec 4.1.2 in The Design of Rijndael
    t = a[0] ^ a[1] ^ a[2] ^ a[3]
    u = a[0]
    a[0] ^= t ^ xtime(a[0] ^ a[1])
    a[1] ^= t ^ xtime(a[1] ^ a[2])
    a[2] ^= t ^ xtime(a[2] ^ a[3])
    a[3] ^= t ^ xtime(a[3] ^ u)
    


def mix_columns(s):
    for i in range(4):
        mix_single_column(s[i])
    return s


def inv_mix_columns(s):
    # see Sec 4.1.3 in The Design of Rijndael
    for i in range(4):
        u = xtime(xtime(s[i][0] ^ s[i][2]))
        v = xtime(xtime(s[i][1] ^ s[i][3]))
        s[i][0] ^= u
        s[i][1] ^= v
        s[i][2] ^= u
        s[i][3] ^= v

    mix_columns(s)
    return s

def matrix2bytes(matrix):
    """ Converts a 4x4 matrix into a 16-byte array.  """
    return bytes(matrix[0] + matrix[1] + matrix[2] + matrix[3])

state = [
    [108, 106, 71, 86],
    [96, 62, 38, 72],
    [42, 184, 92, 209],
    [94, 79, 8, 54],
]

print(matrix2bytes(inv_shift_rows(inv_mix_columns(state))))
```
> crypto{d1ffUs3R}

### 7. Bringing It All Together

---

**_TASK:_**

We've provided the key expansion code, and ciphertext that's been properly encrypted by AES-128. Copy in all the building blocks you've coded so far, and complete the decrypt function that implements the steps shown in the diagram. The decrypted plaintext is the flag.

Yes, you can cheat on this challenge, but where's the fun in that?

The code used in these exercises has been taken from Bo Zhu's super simple Python AES implementation, so we've reproduced the license here.

**_FILE:_**
```py
N_ROUNDS = 10

key        = b'\xc3,\\\xa6\xb5\x80^\x0c\xdb\x8d\xa5z*\xb6\xfe\\'
ciphertext = b'\xd1O\x14j\xa4+O\xb6\xa1\xc4\x08B)\x8f\x12\xdd'



def expand_key(master_key):
    """
    Expands and returns a list of key matrices for the given master_key.
    """

    # Round constants https://en.wikipedia.org/wiki/AES_key_schedule#Round_constants
    r_con = (
        0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40,
        0x80, 0x1B, 0x36, 0x6C, 0xD8, 0xAB, 0x4D, 0x9A,
        0x2F, 0x5E, 0xBC, 0x63, 0xC6, 0x97, 0x35, 0x6A,
        0xD4, 0xB3, 0x7D, 0xFA, 0xEF, 0xC5, 0x91, 0x39,
    )

    # Initialize round keys with raw key material.
    key_columns = bytes2matrix(master_key)
    iteration_size = len(master_key) // 4

    # Each iteration has exactly as many columns as the key material.
    i = 1
    while len(key_columns) < (N_ROUNDS + 1) * 4:
        # Copy previous word.
        word = list(key_columns[-1])

        # Perform schedule_core once every "row".
        if len(key_columns) % iteration_size == 0:
            # Circular shift.
            word.append(word.pop(0))
            # Map to S-BOX.
            word = [s_box[b] for b in word]
            # XOR with first byte of R-CON, since the others bytes of R-CON are 0.
            word[0] ^= r_con[i]
            i += 1
        elif len(master_key) == 32 and len(key_columns) % iteration_size == 4:
            # Run word through S-box in the fourth iteration when using a
            # 256-bit key.
            word = [s_box[b] for b in word]

        # XOR with equivalent word from previous iteration.
        word = bytes(i^j for i, j in zip(word, key_columns[-iteration_size]))
        key_columns.append(word)

    # Group key words in 4x4 byte matrices.
    return [key_columns[4*i : 4*(i+1)] for i in range(len(key_columns) // 4)]


def decrypt(key, ciphertext):
    round_keys = expand_key(key) # Remember to start from the last round key and work backwards through them when decrypting

    # Convert ciphertext to state matrix

    # Initial add round key step

    for i in range(N_ROUNDS - 1, 0, -1):
        pass # Do round

    # Run final round (skips the InvMixColumns step)

    # Convert state matrix to plaintext

    return plaintext


# print(decrypt(key, ciphertext))
```

---

M√¨nh t·ªïng h·ª£p l·∫°i c√°c h√†m ·ªü b√†i tr∆∞·ªõc r·ªìi d·ª±a v√†o thu·∫≠t to√°n m√£ h√≥a ƒë·ªÉ th·ª±c hi·ªán ng∆∞·ª£c l·∫°i. B√†i c≈©ng kh√° d·ªÖ d√†ng v√¨ ƒë√£ c√≥ s·∫µn c√°c h√†m inv t·ª´ b√†i tr∆∞·ªõc.

![image](https://github.com/MinhFanBoy/KCSC_tranning/assets/145200520/3d275a7c-1b2e-4fb2-88e6-04fd36958606)

T·ª´ ƒë√≥ ta c√≥ c√°c b∆∞·ªõc ƒë·ªÉ decrypt nh∆∞ sau:
+ B1: t·∫°o b·∫£ng kh√≥a m·ªü r·ªông
+ B2: th·ª±c hi·ªán h√†m ADD ROUND KEY, ri√™ng h√†m h√†m n√†y ta k c·∫ßn vi·∫øt l·∫°i v√¨ t√≠nh ch·∫•t c·ªßa ph√©p xor
+ B3: Th·ª±c hi·ªán inv_shift, inv_sub, add_key, inv_mix 9 l·∫ßn
+ B4: Th·ª±c hi·ªán n·ªët 3 v√≤ng inv_shift, inv_sub, add_key l√† ta s·∫Ω c√≥ dc plaintext.


```py
N_ROUNDS = 10

key        = b'\xc3,\\\xa6\xb5\x80^\x0c\xdb\x8d\xa5z*\xb6\xfe\\'
ciphertext = b'\xd1O\x14j\xa4+O\xb6\xa1\xc4\x08B)\x8f\x12\xdd'

s_box = (
    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16,
)

inv_s_box = (
    0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
    0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
    0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
    0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
    0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
    0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
    0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
    0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
    0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
    0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
    0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
    0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
    0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
    0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
    0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
    0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D,
)




def sub_bytes(s, sbox=s_box):
    return [[sbox[y] for y in x] for x in s]
def matrix2bytes(matrix):
    """ Converts a 4x4 matrix into a 16-byte array.  """
    return bytes(matrix[0] + matrix[1] + matrix[2] + matrix[3])


def shift_rows(s):
    s[0][1], s[1][1], s[2][1], s[3][1] = s[1][1], s[2][1], s[3][1], s[0][1]
    s[0][2], s[1][2], s[2][2], s[3][2] = s[2][2], s[3][2], s[0][2], s[1][2]
    s[0][3], s[1][3], s[2][3], s[3][3] = s[3][3], s[0][3], s[1][3], s[2][3]
    return s

def inv_shift_rows(s):
    s[1][1], s[2][1], s[3][1], s[0][1] = s[0][1], s[1][1], s[2][1], s[3][1]
    s[2][2], s[3][2], s[0][2], s[1][2] = s[0][2], s[1][2], s[2][2], s[3][2]
    s[3][3], s[0][3], s[1][3], s[2][3] = s[0][3], s[1][3], s[2][3], s[3][3]
    return s


# learned from http://cs.ucsb.edu/~koc/cs178/projects/JT/aes.c
xtime = lambda a: (((a << 1) ^ 0x1B) & 0xFF) if (a & 0x80) else (a << 1)


def mix_single_column(a):
    # see Sec 4.1.2 in The Design of Rijndael
    t = a[0] ^ a[1] ^ a[2] ^ a[3]
    u = a[0]
    a[0] ^= t ^ xtime(a[0] ^ a[1])
    a[1] ^= t ^ xtime(a[1] ^ a[2])
    a[2] ^= t ^ xtime(a[2] ^ a[3])
    a[3] ^= t ^ xtime(a[3] ^ u)
    


def mix_columns(s):
    for i in range(4):
        mix_single_column(s[i])
    return s

def add_round_key(s, k):
    return [[s[i][j] ^ k[i][j] for j in range(4)] for i in range(4)]

def inv_mix_columns(s):
    # see Sec 4.1.3 in The Design of Rijndael
    for i in range(4):
        u = xtime(xtime(s[i][0] ^ s[i][2]))
        v = xtime(xtime(s[i][1] ^ s[i][3]))
        s[i][0] ^= u
        s[i][1] ^= v
        s[i][2] ^= u
        s[i][3] ^= v

    mix_columns(s)
    return s

def matrix2bytes(matrix):
    """ Converts a 4x4 matrix into a 16-byte array.  """
    return bytes(matrix[0] + matrix[1] + matrix[2] + matrix[3])


def expand_key(master_key):
    """
    Expands and returns a list of key matrices for the given master_key.
    """

    # Round constants https://en.wikipedia.org/wiki/AES_key_schedule#Round_constants
    r_con = (
        0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40,
        0x80, 0x1B, 0x36, 0x6C, 0xD8, 0xAB, 0x4D, 0x9A,
        0x2F, 0x5E, 0xBC, 0x63, 0xC6, 0x97, 0x35, 0x6A,
        0xD4, 0xB3, 0x7D, 0xFA, 0xEF, 0xC5, 0x91, 0x39,
    )

    # Initialize round keys with raw key material.
    key_columns = bytes2matrix(master_key)
    iteration_size = len(master_key) // 4

    # Each iteration has exactly as many columns as the key material.
    i = 1
    while len(key_columns) < (N_ROUNDS + 1) * 4:
        # Copy previous word.
        word = list(key_columns[-1])

        # Perform schedule_core once every "row".
        if len(key_columns) % iteration_size == 0:
            # Circular shift.
            word.append(word.pop(0))
            # Map to S-BOX.
            word = [s_box[b] for b in word]
            # XOR with first byte of R-CON, since the others bytes of R-CON are 0.
            word[0] ^= r_con[i]
            i += 1
        elif len(master_key) == 32 and len(key_columns) % iteration_size == 4:
            # Run word through S-box in the fourth iteration when using a
            # 256-bit key.
            word = [s_box[b] for b in word]

        # XOR with equivalent word from previous iteration.
        word = bytes(i^j for i, j in zip(word, key_columns[-iteration_size]))
        key_columns.append(word)

    # Group key words in 4x4 byte matrices.
    return [key_columns[4*i : 4*(i+1)] for i in range(len(key_columns) // 4)]


def bytes2matrix(text):
    return [list(text[i:i+4]) for i in range(0, len(text), 4)]

def decrypt(key, ciphertext):
    round_keys = expand_key(key) # Remember to start from the last round key and work backwards through them when decrypting

    # Convert ciphertext to state matrix
    state = bytes2matrix(ciphertext)
    # Initial add round key step
    state = add_round_key(state, round_keys[10])
    
    for i in range(N_ROUNDS - 1, 0, -1):
        state = inv_shift_rows(state)
        state = sub_bytes(state, sbox=inv_s_box)
        state = add_round_key(state, round_keys[i])
        state = inv_mix_columns(state)
        
        

    # Run final round (skips the InvMixColumns step)
    state = inv_shift_rows(state)
    state = sub_bytes(state, sbox=inv_s_box)
    state = add_round_key(state, round_keys[0])
    
    # Convert state matrix to plaintext

    return matrix2bytes(state)



print(decrypt(key, ciphertext))
```
> crypto{MYAES128}

### 8. Modes of Operation Starter

---

**_TASK:_**

The previous set of challenges showed how AES performs a keyed permutation on a block of data. In practice, we need to encrypt messages much longer than a single block. A mode of operation describes how to use a cipher like AES on longer messages.

All modes have serious weaknesses when used incorrectly. The challenges in this category take you to a different section of the website where you can interact with APIs and exploit those weaknesses. Get yourself acquainted with the interface and use it to take your next flag!

Play at https://aes.cryptohack.org/block_cipher_starter

**_FILE:_**

![image](https://github.com/MinhFanBoy/KCSC_tranning/assets/145200520/f2f774dd-9e99-4d25-853e-795b0356a8fe)

---

B√†i n√†y m√¨nh ch·ªâ c·∫ßn l·∫•y g·ª≠i y√™u c·∫ßu v√† nh√¢n y√™u c·∫ßu t·ª´ web l√† dc n√≥i chung ch·ªâ c·∫ßn vi·∫øt code.

```py


from Crypto.Util.number import *
from requests import *

global url

url = "https://aes.cryptohack.org/block_cipher_starter/"


def decrypt(ciphertext):
    return get(url + "decrypt/" + ciphertext).json()["plaintext"]

def encrypt_flag():
    return get(url + "encrypt_flag").json()["ciphertext"]

print(long_to_bytes(int(decrypt(encrypt_flag()), 16)))
```
> crypto{bl0ck_c1ph3r5_4r3_f457_!}

### 9. Passwords as Keys

---
**_TASK:_**

It is essential that keys in symmetric-key algorithms are random bytes, instead of passwords or other predictable data. The random bytes should be generated using a cryptographically-secure pseudorandom number generator (CSPRNG). If the keys are predictable in any way, then the security level of the cipher is reduced and it may be possible for an attacker who gets access to the ciphertext to decrypt it.

Just because a key looks like it is formed of random bytes, does not mean that it necessarily is. In this case the key has been derived from a simple password using a hashing function, which makes the ciphertext crackable.

For this challenge you may script your HTTP requests to the endpoints, or alternatively attack the ciphertext offline. Good luck!

Play at https://aes.cryptohack.org/passwords_as_keys

**_FILE:_**

```py
from Crypto.Cipher import AES
import hashlib
import random


# /usr/share/dict/words from
# https://gist.githubusercontent.com/wchargin/8927565/raw/d9783627c731268fb2935a731a618aa8e95cf465/words
with open("/usr/share/dict/words") as f:
    words = [w.strip() for w in f.readlines()]
keyword = random.choice(words)

KEY = hashlib.md5(keyword.encode()).digest()
FLAG = ?


@chal.route('/passwords_as_keys/decrypt/<ciphertext>/<password_hash>/')
def decrypt(ciphertext, password_hash):
    ciphertext = bytes.fromhex(ciphertext)
    key = bytes.fromhex(password_hash)

    cipher = AES.new(key, AES.MODE_ECB)
    try:
        decrypted = cipher.decrypt(ciphertext)
    except ValueError as e:
        return {"error": str(e)}

    return {"plaintext": decrypted.hex()}


@chal.route('/passwords_as_keys/encrypt_flag/')
def encrypt_flag():
    cipher = AES.new(KEY, AES.MODE_ECB)
    encrypted = cipher.encrypt(FLAG.encode())

    return {"ciphertext": encrypted.hex()}
```
---

Ta c√≥ th·ªÉ d·ªÖ d√†ng th·∫•y key n·∫±m trong web ·ªü trong file n√™n ta c·∫ßn c√°c key c√≥ th·ªÉ r·ªìi brute t·ª´ng key l√† ra flag.

```py

from Crypto.Util.number import *
from requests import *
from Crypto.Cipher import AES
import hashlib
import random

global url

url = "https://aes.cryptohack.org/passwords_as_keys/"


def encrypt_flag():
    return get(url + "encrypt_flag").json()["ciphertext"]


with open("pass.txt", "r") as f:
    words = [w.strip() for w in f.readlines()]

enc = encrypt_flag()
enc = bytes.fromhex(enc)

for keyword in words:
    KEY = hashlib.md5(keyword.encode()).digest()
    cipher = AES.new(KEY, AES.MODE_ECB)
    tmp = cipher.decrypt(enc)
    if b"crypto" in tmp:
        print(tmp.decode())
        break
    


```
> crypto{k3y5__r__n07__p455w0rdz?}

### 10. ECB CBC WTF

---

**_TASK:_**

Here you can encrypt in CBC but only decrypt in ECB. That shouldn't be a weakness because they're different modes... right?

Play at https://aes.cryptohack.org/ecbcbcwtf

**_FILE:_**
```py
from Crypto.Cipher import AES


KEY = ?
FLAG = ?


@chal.route('/ecbcbcwtf/decrypt/<ciphertext>/')
def decrypt(ciphertext):
    ciphertext = bytes.fromhex(ciphertext)

    cipher = AES.new(KEY, AES.MODE_ECB)
    try:
        decrypted = cipher.decrypt(ciphertext)
    except ValueError as e:
        return {"error": str(e)}

    return {"plaintext": decrypted.hex()}


@chal.route('/ecbcbcwtf/encrypt_flag/')
def encrypt_flag():
    iv = os.urandom(16)

    cipher = AES.new(KEY, AES.MODE_CBC, iv)
    encrypted = cipher.encrypt(FLAG.encode())
    ciphertext = iv.hex() + encrypted.hex()

    return {"ciphertext": ciphertext}
```
---

M√£ h√≥a b·∫±ng CBC v√† gi·∫£i m√£ b·∫±ng CBC, tr∆∞·ªõc khi m√£ h√≥a n√≥ dc xor v·ªõi ciphertext tr∆∞·ªõc n√≥(kh·ªëi ƒë·∫ßu ti√™n xor v·ªõi cv), gi·∫£i m√£ c·ªßa ciphertext ta nh·∫≠n ƒë∆∞·ª£c th√¨ s·∫Ω c√≥ c√°c kh·ªëi nh∆∞ sau:

ciphertext = enc_block_1 +  enc_block_2 + enc_block_3 + enc_block_4 + ...
plaintext = iv $\oplus$ flag_1 +  enc_block_1 $\oplus$ flag_2 ...

t·ª´ ƒë√≥ ta d·ªÖ th·∫•y n·∫øu l·∫•y ciphertext[:16] $\plus$ plaintext[16:32] th√¨ s·∫Ω c√≥ flag, c·ª© ti·∫øp t·ª•c cho t·ªõi khi c√≥ ƒë·ªß flag.

```py

from pwn import xor
from requests import *
from Crypto.Util.number import *

def decrypt(flag: str):
    flag_hex = flag
    s = "https://aes.cryptohack.org/ecbcbcwtf/" + "decrypt/" + flag_hex
    tmp = get(s).json()
    return tmp["plaintext"]

def encrypt():
    url = "https://aes.cryptohack.org/ecbcbcwtf/encrypt_flag/"
    tmp = get(url).json()
    return int("0x" + tmp["ciphertext"], 16)

def main():
    enc_flag = long_to_bytes(encrypt())
    flag = long_to_bytes(int(decrypt(hex(bytes_to_long(enc_flag))[2:]), 16))
    print(xor(enc_flag[:16], flag[16 : 32]).decode() + xor(enc_flag[16:32], flag[32:]).decode())

if __name__ == "__main__":
    main()

```
